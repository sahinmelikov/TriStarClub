import{ad as j,r as y,ae as z,af as K,ag as N,ah as T,ai as F,G,aj as B,ak as I,al as U,p as q,am as x}from"./bIp8vrNC.js";const J=s=>s==="defer"||s===!1;function W(...s){var m,_,v,p,g,P,C,w,b,O;const i=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(i);let[t,d,a={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof d!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const e=I(),M=d,E=()=>null,H=()=>e.isHydrating?e.payload.data[t]:e.static.data[t];a.server=(m=a.server)!=null?m:!0,a.default=(_=a.default)!=null?_:E,a.getCachedData=(v=a.getCachedData)!=null?v:H,a.lazy=(p=a.lazy)!=null?p:!1,a.immediate=(g=a.immediate)!=null?g:!0,a.deep=(P=a.deep)!=null?P:j.deep,a.dedupe=(C=a.dedupe)!=null?C:"cancel";const f=()=>a.getCachedData(t,e)!=null;if(!e._asyncData[t]||!a.immediate){(b=(w=e.payload._errors)[t])!=null||(w[t]=null);const o=a.deep?y:z;e._asyncData[t]={data:o((O=a.getCachedData(t,e))!=null?O:a.default()),pending:y(!f()),error:K(e.payload._errors,t),status:y("idle")}}const r={...e._asyncData[t]};r.refresh=r.execute=(o={})=>{var u;if(e._asyncDataPromises[t]){if(J((u=o.dedupe)!=null?u:a.dedupe))return e._asyncDataPromises[t];e._asyncDataPromises[t].cancelled=!0}if((o._initial||e.isHydrating&&o._initial!==!1)&&f())return Promise.resolve(a.getCachedData(t,e));r.pending.value=!0,r.status.value="pending";const l=new Promise((n,c)=>{try{n(M(e))}catch(S){c(S)}}).then(async n=>{if(l.cancelled)return e._asyncDataPromises[t];let c=n;a.transform&&(c=await a.transform(n)),a.pick&&(c=Q(c,a.pick)),e.payload.data[t]=c,r.data.value=c,r.error.value=null,r.status.value="success"}).catch(n=>{if(l.cancelled)return e._asyncDataPromises[t];r.error.value=U(n),r.data.value=q(a.default()),r.status.value="error"}).finally(()=>{l.cancelled||(r.pending.value=!1,delete e._asyncDataPromises[t])});return e._asyncDataPromises[t]=l,e._asyncDataPromises[t]},r.clear=()=>L(e,t);const D=()=>r.refresh({_initial:!0}),R=a.server!==!1&&e.payload.serverRendered;{const o=N();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const n=o._nuxtOnBeforeMountCbs;T(()=>{n.forEach(c=>{c()}),n.splice(0,n.length)}),F(()=>n.splice(0,n.length))}R&&e.isHydrating&&(r.error.value||f())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(e.payload.serverRendered&&e.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(D):a.immediate&&D();const l=x();if(a.watch){const n=G(a.watch,()=>r.refresh());l&&B(n)}const u=e.hook("app:data:refresh",async n=>{(!n||n.includes(t))&&await r.refresh()});l&&B(u)}const h=Promise.resolve(e._asyncDataPromises[t]).then(()=>r);return Object.assign(h,r),h}function L(s,i){i in s.payload.data&&(s.payload.data[i]=void 0),i in s.payload._errors&&(s.payload._errors[i]=null),s._asyncData[i]&&(s._asyncData[i].data.value=void 0,s._asyncData[i].error.value=null,s._asyncData[i].pending.value=!1,s._asyncData[i].status.value="idle"),i in s._asyncDataPromises&&(s._asyncDataPromises[i].cancelled=!0,s._asyncDataPromises[i]=void 0)}function Q(s,i){const t={};for(const d of i)t[d]=s[d];return t}export{W as u};
